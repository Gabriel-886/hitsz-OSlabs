diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..e69de29
diff --git a/Makefile b/Makefile
index bf95a78..2520821 100644
--- a/Makefile
+++ b/Makefile
@@ -161,7 +161,7 @@ UPROGS=\
 	$U/_zombie\
 	$U/_waittest\
 	$U/_exittest\
-
+	$U/_yieldtest\
 
 ifeq ($(LAB),trap)
 UPROGS += \
diff --git a/kernel/defs.h b/kernel/defs.h
index ecea5e6..b0189ab 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -108,7 +108,7 @@ void            sched(void);
 void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
-int             wait(uint64);
+int             wait(uint64,int);
 void            wakeup(void*);
 void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
diff --git a/kernel/proc.c b/kernel/proc.c
index 1607145..69e6ccf 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -271,12 +271,17 @@ int fork(void) {
 // Caller must hold p->lock.
 void reparent(struct proc *p) {
   struct proc *pp;
-
+  static char *states[] = {
+      [UNUSED] "unused", [SLEEPING] "sleep ", [RUNNABLE] "runble", [RUNNING] "run   ", [ZOMBIE] "zombie"};
+  char *state = "";
+  int child_num = 0;
   for (pp = proc; pp < &proc[NPROC]; pp++) {
     // this code uses pp->parent without holding pp->lock.
     // acquiring the lock first could cause a deadlock
     // if pp or a child of pp were also in exit()
     // and about to try to lock p.
+  
+
     if (pp->parent == p) {
       // pp->parent can't change between the check and the acquire()
       // because only the parent changes it, and we're the parent.
@@ -286,7 +291,11 @@ void reparent(struct proc *p) {
       // initproc->lock, which would be a deadlock, since we hold
       // the lock on one of init's children (pp). this is why
       // exit() always wakes init (before acquiring any locks).
+      if (pp->state >= 0 && pp->state < NELEM(states) && states[pp->state])
+        {state = states[pp->state];}
       release(&pp->lock);
+      exit_info("proc %d exit, child %d, pid %d, name %s, state %s\n",p->pid,child_num,pp->pid,pp->name,state);
+      child_num ++;
     }
   }
 }
@@ -296,9 +305,10 @@ void reparent(struct proc *p) {
 // until its parent calls wait().
 void exit(int status) {
   struct proc *p = myproc();
-
   if (p == initproc) panic("init exiting");
-
+  static char *states[] = {
+      [UNUSED] "unused", [SLEEPING] "sleep ", [RUNNABLE] "runble", [RUNNING] "run   ", [ZOMBIE] "zombie"};
+  char *state = "";
   // Close all open files.
   for (int fd = 0; fd < NOFILE; fd++) {
     if (p->ofile[fd]) {
@@ -331,36 +341,38 @@ void exit(int status) {
   acquire(&p->lock);
   struct proc *original_parent = p->parent;
   release(&p->lock);
-
+  
   // we need the parent's lock in order to wake it up from wait().
   // the parent-then-child rule says we have to lock it first.
   acquire(&original_parent->lock);
 
   acquire(&p->lock);
-
   // Give any children to init.
-  reparent(p);
-
+  if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+        {state = states[p->state];}
+  exit_info("proc %d exit, parent pid %d, name %s, state %s\n",p->pid,original_parent->pid,original_parent->name,state);
+  reparent(p);//孤儿进程会被initproc管理
+  
   // Parent might be sleeping in wait().
   wakeup1(original_parent);
 
   p->xstate = status;
   p->state = ZOMBIE;
-
+  
   release(&original_parent->lock);
-
   // Jump into the scheduler, never to return.
+  
+  
   sched();
   panic("zombie exit");
 }
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int wait(uint64 addr) {
+int wait(uint64 addr,int flag) {
   struct proc *np;
   int havekids, pid;
   struct proc *p = myproc();
-
   // hold p->lock for the whole time to avoid lost
   // wakeups from a child's exit().
   acquire(&p->lock);
@@ -399,9 +411,14 @@ int wait(uint64 addr) {
       release(&p->lock);
       return -1;
     }
-
+    if(flag != 1)
     // Wait for a child to exit.
-    sleep(p, &p->lock);  // DOC: wait-sleep
+    {sleep(p, &p->lock);}  // DOC: wait-sleep
+    else if(flag == 1)
+    {
+      release(&p->lock);
+      return -1;
+    }
   }
 }
 
@@ -472,7 +489,7 @@ void sched(void) {
 void yield(void) {
   struct proc *p = myproc();
   acquire(&p->lock);
-  p->state = RUNNABLE;
+  p->state = RUNNABLE; //设置状态
   sched();
   release(&p->lock);
 }
diff --git a/kernel/syscall.c b/kernel/syscall.c
index 4c97875..97c0229 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -89,14 +89,14 @@ extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
 extern uint64 sys_rename(void);
-
+extern uint64 sys_yield(void);
 static uint64 (*syscalls[])(void) = {
     [SYS_fork] sys_fork,   [SYS_exit] sys_exit,     [SYS_wait] sys_wait,     [SYS_pipe] sys_pipe,
     [SYS_read] sys_read,   [SYS_kill] sys_kill,     [SYS_exec] sys_exec,     [SYS_fstat] sys_fstat,
     [SYS_chdir] sys_chdir, [SYS_dup] sys_dup,       [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk,
     [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open,     [SYS_write] sys_write,
     [SYS_mknod] sys_mknod, [SYS_unlink] sys_unlink, [SYS_link] sys_link,     [SYS_mkdir] sys_mkdir,
-    [SYS_close] sys_close, [SYS_rename] sys_rename,
+    [SYS_close] sys_close, [SYS_rename] sys_rename,[SYS_yield] sys_yield,
 };
 
 void syscall(void) {
diff --git a/kernel/syscall.h b/kernel/syscall.h
index 6998f87..ce5a3f3 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -21,3 +21,4 @@
 #define SYS_mkdir  20
 #define SYS_close  21
 #define SYS_rename 22
+#define SYS_yield  23
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index a69071e..3abe03f 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -20,8 +20,10 @@ uint64 sys_fork(void) { return fork(); }
 
 uint64 sys_wait(void) {
   uint64 p;
+  int flag;
   if (argaddr(0, &p) < 0) return -1;
-  return wait(p);
+  if(argint(1, &flag) < 0) return -1;
+  return wait(p,flag);
 }
 
 uint64 sys_sbrk(void) {
@@ -81,3 +83,13 @@ uint64 sys_rename(void) {
   p->name[len] = '\0';
   return 0;
 }
+
+uint64 sys_yield(void)
+{
+  struct proc *p = myproc();
+  struct trapframe *t = p->trapframe;
+  int pc = t->epc;
+  printf("start to yield, user pc %p\n",pc-4);
+  yield();
+  return 0;
+}
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..bf0d87a
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+4
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index ec47d9d..8bd5d6d 100644
--- a/user/user.h
+++ b/user/user.h
@@ -24,7 +24,7 @@ char* sbrk(int);
 int sleep(int);
 int uptime(void);
 int rename(const char*);
-
+void yield(void);
 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
diff --git a/user/usys.pl b/user/usys.pl
index 3a2f6c4..c17d993 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -37,3 +37,4 @@ entry("sbrk");
 entry("sleep");
 entry("uptime");
 entry("rename");
+entry("yield");
\ No newline at end of file
